// Prisma schema for CRM Subscription Plans and Monetization
// Provider: PostgreSQL (Neon)

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

enum BillingCycle {
  monthly
  yearly
}

enum ProductType {
  product
  addon
  service
  subscription
}

enum SubscriptionStatus {
  active
  trialing
  past_due
  canceled
  incomplete
  incomplete_expired
  unpaid
  paused
}

model SubscriptionPlan {
  id            String       @id @default(uuid())
  name          String
  price         Float        @default(0)
  billingCycle  BillingCycle @default(monthly)
  description   String?
  userLimit     Int          @default(1)
  propertyLimit Int          @default(10)
  isActive      Boolean      @default(true)
  features      String[]
  pages         String[]
  tools         String[]
  services      String[]
  paymentTypes  String[]
  backupTypes   String[]
  subscriptions Subscription[]
  createdAt     DateTime     @default(now())
  updatedAt     DateTime     @updatedAt
}

model Product {
  id          String      @id @default(uuid())
  name        String
  description String?
  type        ProductType @default(product)
  price       Float       @default(0)
  isActive    Boolean     @default(true)
  category    String?
  tags        String[]
  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @updatedAt
}

model Subscriber {
  id          String         @id @default(uuid())
  email       String         @unique
  companyName String?
  subscriptions Subscription[]
  createdAt   DateTime       @default(now())
  updatedAt   DateTime       @updatedAt
}

model Subscription {
  id                   String              @id @default(uuid())
  subscriberId         String
  subscriber           Subscriber          @relation(fields: [subscriberId], references: [id])
  planId               String?
  plan                 SubscriptionPlan?   @relation(fields: [planId], references: [id])
  status               SubscriptionStatus  @default(active)
  startDate            DateTime            @default(now())
  endDate              DateTime?
  stripeCustomerId     String?
  stripeSubscriptionId String?
  cancelAtPeriodEnd    Boolean             @default(false)
  payments             Payment[]
  revenueEvents        RevenueEvent[]
  createdAt            DateTime            @default(now())
  updatedAt            DateTime            @updatedAt
}

model Payment {
  id             String        @id @default(uuid())
  subscriptionId String
  subscription   Subscription  @relation(fields: [subscriptionId], references: [id])
  amount         Float
  currency       String        @default("usd")
  status         String
  provider       String        @default("stripe")
  externalId     String?
  createdAt      DateTime      @default(now())
}

model RevenueEvent {
  id             String        @id @default(uuid())
  subscriptionId String?
  subscription   Subscription? @relation(fields: [subscriptionId], references: [id])
  type           String
  amount         Float
  metadata       Json?
  createdAt      DateTime      @default(now())
}

/// ----------------------------------------------------------
///  NEW MODELS FOR TENANTâ€‘LEDGER / PAST BALANCES
/// ----------------------------------------------------------

enum LeaseStatus {
  ACTIVE
  TERMINATED   // tenant moved out but balance may still exist
  CLOSED       // all balances settled, can be archived
}

enum EntryType {
  RENT
  DEPOSIT
  FEE
  PAYMENT
  ADJUSTMENT
}

model Property {
  id        String   @id @default(uuid())
  address   String
  units     Unit[]
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Unit {
  id         String   @id @default(uuid())
  number     String
  propertyId String
  property   Property @relation(fields: [propertyId], references: [id])
  leases     Lease[]
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  @@index([propertyId])
  @@unique([propertyId, number])
}

model Tenant {
  id        String   @id @default(uuid())
  name      String
  email     String?
  leases    Lease[]
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Lease {
  id            String        @id @default(uuid())
  unitId        String
  tenantId      String
  startDate     DateTime
  endDate       DateTime?
  status        LeaseStatus   @default(ACTIVE)
  archived      Boolean       @default(false)   // hide from active UI if desired
  unit          Unit          @relation(fields: [unitId], references: [id])
  tenant        Tenant        @relation(fields: [tenantId], references: [id])
  ledgerEntries LedgerEntry[]

  @@index([status])                     // fast lookup of terminated leases
  @@index([tenantId])
  @@index([unitId])
}

model LedgerEntry {
  id          String    @id @default(uuid())
  leaseId     String
  lease       Lease     @relation(fields: [leaseId], references: [id])
  date        DateTime  @default(now())
  description String
  amountCents Int       // positive = charge, negative = payment
  type        EntryType

  @@index([leaseId])
}
